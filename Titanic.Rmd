---
title: "Titanic"
author: ""
date: "5/8/2020"
output:
  html_document:
    toc :  yes
  pdf_document:
    toc :  yes
  word_document:
    toc : yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, include=FALSE}
setwd("D:/GoogleDrive/Master's Degree Data Science/2020Q1_Tipología y ciclo de vida de los datos/Práctica 2 - Limpieza y Análisis de Datos/PRAC2")
```


## 1. Introducción

Explicar porque el dataset y que tecnica se va a usar para clasificiar. 

## 2. Descripción del juego de datos.


## 3. Carga de datos

Primero se cargan los datos mediante la funcion `read.csv()`. 

```{r carga de datos}
# Carga del juego de datos
datos<-read.csv("train.csv", sep = ",", header = TRUE)

attach(datos)
```

Una vez cargados los datos, se evalúa su estructura y se obtiene una breve descripción de ellos. A continuación, se cuenta el número de NA y la existencia de valores vacíos para cada variable. 

```{r descripción de los datos}

# Estructura de los datos
str(datos)

# Descipción de los datos
summary(datos)

# Presencia de valores NA
colSums(is.na(datos))

# Presencia de valores vacíos
colSums(datos=="")


```

El número total de observaciones son 891. Respecto a la descripción de las variables tenemos 5 en formato *integer* (**PassangerID**, **Survived**, **Pclass**, **SibSp**, **Parch**), 5 en formato *factor*(**Name**, **Sex**, **Ticket**, **Cabin** y **Embarked**) y 2 en formato *numeric* (**Age** y **Fare**). Mediante la función `summary()`se muestra tambien una breve descripción de las mismas. 

Referente a que variables se encuentran incompletas, la variable **Age** tiene 177 NA, mientras que las variables **Cabin** y **Embarked** presentan 687 y 2 valores vacíos respectivamente. 

A continuación se pasarán a analizar las variables de forma individual teniendo en cuenta que el mayor interés se centra en su relación con la variable **Survived** ya que el fin de este preprocesado preparar el juego de datos para poder predecir la probabilidad de cada pasajero de sobrevivir. 

## 4. Análisis de las variables 
Hay dos variables que no se van a analizar ya que presentan un valor diferente para cada observación (i.e. 891) y por lo tanto no pueden ser indicativas de ninguna tendencia en los datos referente a la supervivencia. Estas variables son el identificador del pasajero (**PassengerID**), cuyo objetivo es identificar a cada pasajero por por un número, y la variable nombre (**Name**), que identifica a cada pasajero por su nombre. 

```{r variables únicas }
apply(datos, 2, function(x) length(unique(x)))
```

### 4.1. Variable Pclass
Esta variable es indicativa de la clase a la que pertenece cada pasajero, y tiene valores entre 1 y 3, siendo 1 la clase más alta y la 3 la más baja. Como se ha visto con anterioridad no presenta ni valores NA ni vacíos.  Para ver su relación con la tasa de supervivencia primero se pasa a variable categórica tanto la variable **Survived** como **Pclass** con la función `as.factor()` y después se hace un gráfica de barras de cada clase con el porcentaje de supervivencia. 

A continuación, se analiza la distribución de la variable. Debido a que es una variable categóricno no encontramos valores extremos.

```{r distribution Pclass}
f.relativas.Pclass <- sort(
  round(100*table(Pclass)/sum(table(Pclass)), 2), 
  decreasing = TRUE
)

barplot(
  f.relativas.Pclass,
  col = 'salmon',
  main = 'Diagrama de barras Pclass',
  xlab = 'pclass',
  ylab = 'frecuencia relativa (%)',
  ylim = c(0, 60)
)
```

En el diagrama de barras de las frecunecias relativas se observa que la mayor cantidad de pasajeros viajaban en tercera clase.

```{r variable Pclass, message = FALSE }
library(ggplot2)
# Se pasa a variable categórica Survived 
datos$Survived<-as.factor(datos$Survived)

# Se pasa a variable categórica Pclass
datos$Pclass<-as.factor(datos$Pclass)

# Gráfica
ggplot(
  data = datos,aes(x=Pclass,fill=Survived)
  ) + geom_bar(position="fill") + ylab("Frecuency") + xlab("Class")
```

Se observa como a clase más alta existe mayor probabilidad de supervivencia. 

### 4.2. Variable Sex
Esta clase presenta dos categorias: *female* y *male*, para mujeres y hombres respectivamente. Como se ha visto con anterioridad no presenta ni valores NA, ni imcompletos. 

Analizamos la distribución de la variable.

```{r distribution Sex}
f.relativas.Sex <- sort(
  round(100*table(Sex)/sum(table(Sex)), 2), 
  decreasing = TRUE
)

barplot(
  f.relativas.Sex,
  col = 'salmon',
  main = 'Diagrama de barras Pclass',
  xlab = 'pclass',
  ylab = 'frecuencia relativa (%)',
  ylim = c(0, 80)
)
```

Se observa que la mayor cantidad de pasajeros eran hombres. Su representación gráfica con respecto a la supervivencia se muestra a continuación. 


```{r variable Sex }

# Gráfica
ggplot(data = datos,aes(x=Sex,fill=Survived))+geom_bar(position="fill")+ylab("Frecuency")+xlab("Sex")

```

Se observa como la probabilidad de supervivencia aumenta notablemente por el hecho de ser mujer. 

### 4.3. Variable Age

En primer lugar, analizamos la dsitribución de la variable Age.

```{r Age distribution}
# dibujamos el histograma con la línea de densidad sin tener en cuenta 
# los valores nulos
hist(Age, col = 'darkslategray1',
     main = 'Histograma + densidad de la variable Age',
     freq = FALSE,
     xlab = 'Age')
lines(density(Age[!is.na(Age)]), col = 'red', lwd='3')
```

Una vez conocida la distribución de la variable **Age** (edad), que no sigue una distribución normal en todos sus valores, es necesario trabajar los valores nulos. Esta presenta un total de 177 valores NA que se han de estudiar para  tomar una decisión a cerca de su tratamiento. Debido al gran numero con respecto al total (177 sobre 891) no se aconseja eliminar los casos. Por lo tanto, primero se evaluará si dichos valores (nulos) tienen una relación con el hecho que el indidividuo sobreviva o no. Anterioremente, se ha visto que la clase determina en cierto modo las proabibilidades de sobrevivir o no, y posiblemente el hecho de disponer o no de la edad puede depender de la clase. Para ver si hay o no dependencia entre **Survived** y **Age** primero se categorizará la variable **Age** en función de si se especifica o no la edad, para posteriomente hacer un test *Chi-cuadrado* de independencia de variables mediante la función `chisq.test()`. 

$$
\text{Hipótesis nula. } H_0 \text{: Las variables son independientes.}
\\
\text{Hipótesis alternativa. } H_1 \text{: Las variables  no son independientes.}
$$
```{r variable Age valores no presentes, message = FALSE }
library(plyr)
# Se obtiene la variable
edad_presente<-datos$Age

# Categorización de variable en función de presencia o ausencia de edad
edad_presente[which(datos$Age!=is.na(datos$Age))] = 1
edad_presente[which(is.na(datos$Age))] = 0
edad_presente<-mapvalues(
  edad_presente,
  from = c("0", "1"),
  to = c("edad_no_especificada", "edad_especificada")
)

####### CONSULTAR
edad_presente_bis <- sapply(Age, function (age) if (is.na(age)) "edad_no_especificada" else "edad_especificada")
####### CONSULTAR

# Creación de tabla de contingencia 
table_prop<-table(edad_presente,datos$Survived)

# Test Chi cuadrado
chisq.test(table_prop)
```

Como se puede observar el $\text{p-valor} < \alpha=0.05$, done $\alpha = 0.05$ es el nivel de significación para un nivel de confianza del 95%, por lo tanto, rechazamos $H_0$  concluyendo que las variables son dependientes, luego existe una relación entre haber proporcionado la edad y la supervivencia.  

Por ello, no se recomienda hacer ningun cálculo como puede ser la media para completar esta variable ya que le estariamos dando un valor promedio no beneficiandonos de su posible poder de predicción para el análisis. Una posible solución es imputar los valores por medios probabilísticos a partir de la funcion `knn()`, y que los casos más cercanos en cuanto a otros atributos determinen el valor. Sin embargo, el gran número de casos de esta variable puede hacer que su gran numero de predicciones (177 sobre 891) la haga poco realista provocando errores. Se optará por discretizar la variable en función de grupos de edad, y crear un grupo con estas valores con la etiqueta *not_specified*.  Para ello se ve si existe primero alguna relación entre edad y supervivencia, para posteriomente crear los grupos. Mediante el histograma que abajo se muestra en número totales, se observa como la distribución de la variable no es del todo normal, ya que a edades bajas hay mas población de la esperada, y que esta tiene una mayor probabilidad de supervivencia. Además mediante un `box_plot()`se observa la presencia de *outliers*, sin embargo como se va a discretizar la variable no presentan ningún problema.

```{r variable Age distribución }
# Datos donde se especifica la edad
Age_specified<-datos$Age[which(datos$Age!=is.na(datos$Age))]
Survived_age_specified<-datos$Survived[which(datos$Age!=is.na(datos$Age))]

data_age <- data.frame(matrix(ncol = 2, nrow = length(Age_specified)))
colnames(data_age) <- c("Age_specified", "Survived_age_specified")

data_age$Age_specified<-Age_specified
data_age$Survived_age_specified<-Survived_age_specified

###### CONSULTAR
age_survived_with_specified_age <- subset(
  datos[!is.na(datos$Age), ],
  select = c(Age, Survived)
)
###### CONSULTAR

# Grafico de conteos totales en
ggplot(data = data_age, aes(x=Age_specified, fill=Survived_age_specified))+geom_histogram(bins = 80)

# Gráfico para observar valores extremos

boxplot(data_age$Age_specified, main = "Age", ylab = "years", col="orange")

```

En el histograma de la variable age junto con la probabilidad de supervivencia es posible observar que a menos edad mayor tasa de supervivencia. Por lo tanto, nos encontramos ante un escenario dónde sabemos que la edad no especificada es dependiente con la variable survived. Además, pertenecer al rango de menos edad significa tener más probabilidad de sobrevivir. Por lo tanto, para discretizar la variable se ha de escoger un valor óptimo que discretice la edad en grupos maximizando la información sobre la supervivencia o no del pasajero.Para ello se usará los *Odds-Ratio* que nos medirá si es más probable sobrevivir, de esta forma, obtendremos el valor de la edad dónde es aún significativo para determinar la supervivencia respecto a la edad. Para ello se van a escoger edades entre 1 y 30 como humbral de discrimanción y se va a hacer un gráfico con el resultado. 

```{r variable Age odds ratop de supervivencia}
survived_age<-relevel(data_age$Survived_age_specified,ref="1")

result<-double(30)

for (i in 1:30){
  age_th<-data_age$Age_specified
  age_th[which(data_age$Age_specified<=i)] = 1
  age_th[which(data_age$Age_specified>i)] = 0
  age_th<-as.factor(age_th)
  age_th<-relevel(age_th,ref="1")
  tabla<-table(age_th,survived_age)
  or<-(tabla[1]*tabla[4])/(tabla[2]*tabla[3])
  result[i]<-or
}

plot(result, xlab ="Age", ylab="Odds-Ratio", yaxp  = c(0, 10, 10))
```

Como se puede observar , a medida que disminuye la edad aumenta la probabilidad de supervivencia, la cual se mantiene al doble para edades menores de 16 años. A partir de 21, se puede considerar que no hay diferencias sustanciales siendo la *Odds-ratio* similiar a 1. Escoger una edad muy baja, mejora la predicción , pero sin embargo como la mayoria de la poblacion como se ve en el histograma esta concentrada en edades alrededor de 30 años , esta variable dejará de ser util para un segmento amplio de nuestro juego de datos. Escoger un valor muy alto de edad, puede hacer la variable mas util para una mayor parte del juego de datos pero con menor capacidad predictiva. Por ello se escogera un valor de compromiso, considerando como que el doble de probabilidad de supervivencia es un buen indicador y además incluye a un amplio segmento de la población joven, por lo que para discretizar la variable se usará 16 años como limite entre niño y adulto. Teniendo en cuenta esto la variable **Age** se discretizará de la siguiente manera. Tambien se muestra el resultado final en comparación von la variable supervivencia. 

```{r discretización variable age}
## Grupos niño, adulto y sin especificar

edad<-datos$Age

edad[which(edad<= 16)] <- 1
edad[which(edad>16)] <- 2
edad[which(is.na(datos$Age))] <- 0

edad<-mapvalues(edad, from = c("0", "1","2"), to = c("not_specified", "child", "adult"))

datos$Age_cat<-as.factor(edad)
datos$Age_cat<-relevel(datos$Age_cat, ref="child")

# Gráfica
ggplot(data = datos,aes(x=Age_cat,fill=Survived))+geom_bar(position="fill")+ylab("Frecuency")+xlab("Sex")

```

### 4.4. Variable SibSp
Esta variable hace referencia al número de conyuges y hermamos. Toma valores entre 0 y 8, y no presente ningún valor NA o vacío. Se considera que esta variable es categórica, por lo tanto, se realiza su conversión y se analiza su distribución mediante un diagrama de barras con las frecuencias relativas.

```{r}
f.relativas.SibsSp <- sort(
  round(100*table(as.factor(SibSp))/sum(table(as.factor(SibSp))), 2), 
  decreasing = TRUE
)

barplot(
  f.relativas.SibsSp,
  main = 'Barplot variable Sibsp',
  col = 'Salmon',
  xlab = 'Sibsp',
  ylab = 'frecuency'
)
```

Como se puede observar en el gráfico anterior la mayor parte de los pasajeros viajaban solos. Los siguientes grupos son más frecuentes son 1 y 2 parientes.

Si se hace un gráfica de cada grupo con respecto a la supervivencia se observa como existe una mayor proabilidad de supervivencia en  grupos de parientes con 1 o 2 miembros.

```{r variable SibSp }

datos$SibSp<-as.factor(datos$SibSp)

ggplot(data = datos,aes(x=as.factor(SibSp),fill=Survived))+geom_bar(position="fill")+ylab("Frecuency")
```

Analizamos si la variable SibsSp tiene alguna relación con Sex y PClass.

```{r, results='hide'}
library(gridExtra)
```

```{r}
g1 <- ggplot(data = datos,aes(x=as.factor(SibSp),fill=Sex))+geom_bar(position="fill")+ylab("Frecuency")+xlab("SibsSp")
g2 <- ggplot(data = datos,aes(x=as.factor(SibSp),fill=Pclass))+geom_bar(position="fill")+ylab("Frecuency")+xlab("SibsSp")
grid.arrange(g1, g2, ncol=1, nrow=2)
```

Tras analizar los gráficos anteriores, vemos que la mayoría de los pasajeros que viajaban solos eran hombres y esto explica porque la tasa de supervivencia es inferior pese a ser el grupo con mayor proporción de pasajeros pese a ser uno de los grupos con más pasajeros en primera y segunda clase. Otro dato curioso es que las familias de más miebros tienen la tasa de supervivencia más baja, a su vez estos grupos pertenecen a tercera clase y en su mayoría eran hombres.

Para entender más los datos y la relación entre sus variables realizamos algunos test de chi-cuadrado entre la variable SibSp y Sexo, SibSp y Pclass y Sibsp y Survived para entender si estas son dependientes o no.

```{r}
chisq.test(as.factor(SibSp), as.factor(Sex))
chisq.test(as.factor(SibSp), as.factor(Pclass))
chisq.test(as.factor(SibSp), as.factor(Survived))
```

Observamos que las tres variables son muy significativas y dependientes entre ellas. Además, se ha visto que las tres explican la supervivencia o no de los pasajeros.

### 4.5. Variable Name

La variable **Name** contiene el nombre y apellidos de los pasajeros. A partir de esta variable podemos separar el nombre del pasajero con el apellido. No se considera que sea una variable determinística para predecir los datos, pero su análisis puede ayudar a entender a comprender más su naturaleza.

En primer lugar, separamos la varaible nombre de los apellidos y generamos nuevos atributos y representamos las 10 familias más numerosas.

```{r}
library(stringr)
# generamos un pattern para separar el texto
pattern = "(.+),(.+)"
# generamos los nobres y los apellidos
datos$surnames <- str_match(Name, pattern)[, 2]
datos$names <- str_match(Name, pattern)[, 3]

# calculamos las frecuencias relativas
f.surnames <- sort(table(datos$surnames), decreasing = TRUE)[1:10]

x <- barplot(f.surnames, xaxt = 'n', horiz = F,
             main = 'Surnames - Frecuencias absolutas',
             xlab = 'surnames',
             ylab = 'frecuencia',
             col = 'salmon')
labs <- names(f.surnames)

# surnames a 45 grados
text(cex=1, x=x-.25, y=-1.25, labs, xpd=TRUE, srt=45)


```

En el gráfico anterior se han mostrado las 10 familias con más miembros en el Titanic. Imprimimos todos los pasajeros de la misma familia de las familias Andersson y Goodwin para analizar la naturalidad de los datos.

```{r}
datos[datos$surnames=='Andersson' | datos$surnames=='Carter', c(4, 9)]
```

Tras analizar estos datos, es posible sacar algunas conclusiones que explican la naturaleza de los datos. Por ejemplo, cuando dos o más personas tienen el mismo ticket y precio es que pertenecen  a la mismsa familia.

```{r}
datos[datos$Ticket=='347082', c(4, 9)]
```

Por ejemplo, la familia Andersson con número de ticket 347082 de 7 miembros (ninguno de ellos sobrevivió) tiene el mismo número de ticket y costó el mismo precio.

La variable **Name** ayuda a entender los datos, pero la información está instrínseca dentro de los tickets, precios e incluso los números de parientes. Por lo tanto, más allá de una variable que nos ayude a comprender que familias iban a bordo del Titanic no es una variable explicativa para alimentar el algoritmo ya que estaríamos especializando al algoritmo.

### 4.6. Variable Parch

Esta variable hace referencia al número de padres e hijos. No presenta ningún valor NA o vacía, y oscila en el rango de 0 a 6. Se va a categorizar transformándola con la función `as.factor()` y presenar su distribución mediante un diagrama de barras con sus frecuencias relativas.

```{r variable Parch }
# as factor
datos$Parch<-as.factor(datos$Parch)

f.relativas.Parch <- sort(
  round(100*table(as.factor(Parch))/sum(table(as.factor(Parch))), 2), 
  decreasing = TRUE
)

barplot(
  f.relativas.Parch,
  main = 'Barplot variable Parch',
  col = 'Salmon',
  xlab = 'Sibsp',
  ylab = 'frecuencias',
  ylim = c(0,80)
)
```

Si se hace un gráfica de cada grupo con respecto a la supervivencia se observa como existe una mayor proabilidad de supervivencia en  grupos de familías  de  1 a 3 miembros pese a qué la mayor cantidad de pasajeros a bordo del Titanic eran unifamiliares. Esto puede ser debido a qué era más probable encontrar que las familias tuvieran hijos o mujeres.

```{r}
ggplot(data = datos,aes(x=Parch,fill=Survived))+geom_bar(position="fill")+ylab("Frecuency")
```

Si la variable **SibSp** nos indica el número de conyuges o hermanos y la variable **Parch** nos indica el número de padres e hijos debe de haber una relación entre dichas variables.

```{r}
chisq.test(Parch, SibSp)
```

Analizamos la distribución entre ambas variables.

```{r}
g1 <- ggplot(datos, aes(x=factor(Parch)))+
  geom_bar(stat="count", width=0.7, fill="steelblue")

g2 <- ggplot(datos, aes(x=factor(SibSp)))+
  geom_bar(stat="count", width=0.7, fill="steelblue")

grid.arrange(g1, g2, ncol=1, nrow=2)
```

Hemos visto que ambas variables son dependientes y anteriormente hemos comprobado que SibSp tiene significancia entre sobrevivir o no. Para no solapar ambas variables en el algoritmo de predicción se crea una nueva variable que contenga el número de parientes la cual será la suma de ambas variables.

```{r}
# creamos la nueva variable
datos$Parents <- as.factor(as.integer(datos$SibSp) + as.integer(datos$Parch))
```

```{r, results='hide'}
detach(datos)
attach(datos)
```


```{r}
# comprobamos si es estadísticamente significativa para survived
chisq.test(Parents, Survived)
```

Con un nivel de significación del 0.05 confirmamos que la nueva variable es significativa para entender si sobrevive o no.



### 4.7. Variable Fare

Esta variable nos indica el valor del billete. Se ha de suponer que las clases superiores tendrán un precio más elevado, que ya se ha visto que parece aumentar la probabilidad de supervivencia. Por lo tanto se considerá para el análisis. La variable es contínua y no presenta valores NA ni vacios. Sin embargo, mirando los valores mínimos de la variable, se observa que tiene valores con 0 que se muestran a continuación. 


```{r variable Fare valores 0 }
nrow(datos[which(datos$Fare==0), ])
```

Analizamos la distribución de la variable.

```{r}
hist(Fare, col = 'darkslategray1',
     main = 'Histograma + densidad de la variable Fare',
     freq = FALSE,
     xlab = 'Fare')
lines(density(Fare), col = 'red', lwd='3')
```


Estos 15 valores pertencen a datos que no se han rellenado por lo que debido al bajo número se procederá a la imputación de datos a partir del método de los vecinos más próximos mediante la función `kNN()`. Para ello se seleccionaran como variables las que pueden tener relación con el valor del billete: Clase del billete (**Pclass**), si es o no de cabina (**Cabin**) y el lugar de embarque (**Embarked**). No se usará la edad, ya que hay una elevada proporción de valores no espeficicados. La variable **Embarked** tiene dos valores vacíos, pero ninguno de ellos coincide con los valores que queremos imputar.

```{r imputacion Fare, message = FALSE}
library(dplyr)
library(VIM)

# Se crea el datFrame para imputar los valores 
datos_imputacion<-select(datos,Pclass,Embarked,Cabin,Fare)

# Se pasan a NA los valores que queremos imputar
index_imputados_fare<-which(datos$Fare==0)
datos_imputacion$Fare[index_imputados_fare]<-NA

# Se escojen 3 vecinos más proximos
datos_imputados<-kNN(datos_imputacion,k=3)

# Se muestran los datos imputados
datos_imputados$Fare[index_imputados_fare]

# Se pasan al dataFrame original
datos$Fare<-datos_imputados$Fare
```

Una vez imputados los valores se observa si siguen una distribución normal. Debido a la naturaleza de la variable, donde han de predemoniar los precios bajos ésta sigue una distribución lognormal. Mediante la  transformación de Box Cox se intenta mejorar la normalidad y homocedasticidad. Aunque la distribución de la variable mejora y se asemeja más a una distribución normal, todaviá no pasa el test de normalidad de *saphiro* ya que el p-valor es menor a 0.05, rechazando la hipótesis nula de que los datos tienen una distribución normal.  

```{r Fare normalidad, message = FALSE }
library(DescTools)

x <- scale(datos$Fare)
x.norm<- BoxCox(x, lambda = BoxCoxLambda(x))

par(mfrow=c(2,2)) 

qqnorm(x, main="Lognormal") 
qqline(x,col=2)

qqnorm(x.norm, main="Box-Cox")
qqline(x.norm,col=2)

hist(x,main="Lognormal", xlab = "Fare", col="orange") 
hist(x.norm, main="Box-Cox", xlab = "Fare", col="orange")

# Test de normalidad
shapiro.test(x.norm)

# Se introducen los datos en el dataFrame

datos$Fare_norm <-x.norm

```

Se probarán tanto la variable transformada como la variable original en el algoritmo para ver cual tiene mejor capacidad de predicción.

### 4.8. Variable Embarked
La variable **Embarked** tiene 3 niveles diferentes, e informa del puerto en que embarcó el pasajero. Contiene dos valores vacios que al igual que en el caso de **Fare** serán imputados. Para esta imputación se usarán tambien las variables **Fare**, **Pclass** y **Cabin**, ya que se entiende que ha de haber una relación entre precio, si es cabina o no, la clase  y la ciudad de embarque.
```{r variable Embarked imputacion, message = FALSE }
library(gdata)

# Se crea el datFrame para imputar los valores 
datos_imputacion<-select(datos,Embarked,
                         Fare,Pclass,Cabin)
# Se pasan a NA los valores que queremos imputar
index_imputados_embarked<-which(datos$Embarked=="")
datos_imputacion$Embarked[index_imputados_embarked]<-NA

# Se escojen 3 vecinos más proximos
datos_imputados<-kNN(datos_imputacion,k=3)

# Se muestran los datos imputados
datos_imputados$Embarked[index_imputados_embarked]

# Se pasan al dataFrame original y se eliminan los niveles que ya no se usan (i.e. "")
datos$Embarked<-datos_imputados$Embarked
datos$Embarked<-drop.levels(datos$Embarked)

```
Finalmente se observa que la probabilidad de supervivencia varia en función del lugar de embarque, aunque puede ser  debido a que personas de diferente clase embarquen en preferentemente en sitios diferentes. 

```{r grafica embarked }

ggplot(data = datos,aes(x=Embarked,fill=Survived))+geom_bar(position="fill")+ylab("Frecuency")


```

### 4.9. Variable Ticket y Cabin

La variable **Ticket** es indicativa del número de ticket de cada pasajero por lo que tiene un total de 681 valores únicos, sabemos que esto es debido a qué todos los miembros de una misma familia tienen el mimso número de ticket. No se va a utilizar para el análisis ya que no se considera que de información relevante, o más bien pese a qué pueda tener una dependencia con la variable survived estaríamos especializando el algoritmo a nuestro set de datos de entrenamiento. Respecto a la variable **Cabin**, da información de la cabina donde se alojó un pasajero. Los valores vacios corresponden a pasajeros que no se han alojado en cabina. Como se ha visto con anterioridad, la clase en la que se alojó un pasajero puede influir en su supervivencia, así que es de esperar que el hecho que esté alojado en cabina o no pueda tambien afectar a su posisbilidad de vivir, ya que se entiende que el alojarse en cabina es más caro.

En primer lugar, queremos saber si el precio definido en al variable **Fare** es diferente cuando la variable **Cabin** está informada. Para ello definimos la siguiente contraste de hipótesis de medias de los subconjuntos según la cabina está informada o no.

$$
H_0: \mu_1 = \mu_2
\\
H_1: \mu_1 \neq \mu_2
\\
\text{donde, 1 es el conjunto con Cabin especificada y 2 no.}
$$

Debido a que la variable Fare no es normal, pero tenemos más de 30 muestras para cada una podemos aplicar el teorema del límite central, luego tenemos la variable $\frac{\overline{X}_1 - \overline{X}_2}{S_{\overline{X}_1 - \overline{X}_2}}$ que sigue una distribución normal $N(0, 1)$.

```{r}
# generamos una función para calcular el estadístico z por el teorema del límite central
calculate_z <- function(x, y) {
  # calculamos el numerador
  z_num <- mean(x) - mean(y)
  z_den <- sqrt(
    ((sd(x)^2)/length(x))
    +
    ((sd(y)^2)/length(y))
  )
  z <- z_num / z_den
  z
}

z <- calculate_z(datos[datos$Cabin!="", ]$Fare, (datos[datos$Cabin=="", ]$Fare))
z;
```

Debido a que z sigue una distribución normal, entonces el p-valor corresponidente es:

$$
p = 2P(Z>|z|)
$$

```{r}
0.05 < 2*pnorm(z, lower.tail = F)
```

Debido a que el p-valor es inferior al nivel de significancia fijado como $\alpha=0.05$ rechazamos la hipótesis nula a favor de la hipótesis alternativa y podemos considerar que los precios entre tener cabina informada o no son diferentes. Por lo tanto, trataremos aquellos registros cuya cabina no está infomrada que se consideren valores extremos como cabinas informadas. Para los que tengan cabina informada asumiremos que es correcto.

A continuación, queremos afirmar si existe alguna relación entre la variable Fare y los diferentes Embarked para entonces, categorizar la variable en dependencia de ellos.

```{r}
for (e in unique(Embarked[Embarked!=''])) { 

  z <- calculate_z(datos[datos$Embarked==e, ]$Fare, datos[datos$Embarked!=e, ]$Fare)
  result <- 0.05 < 2*pnorm(z, lower.tail = F)
  
  print(paste('Las medias Fare de embarked: ', e, ' y las otras son iguales -> ', result, sep = ''))
}
```

Por lo tanto, con un nivel de significancia del 0.05 podemos afirmar que para Embarked 'C' la media variable Fare es diferente de las otras y debemos considerarla para separar los navegantes con cabina y sin cabina. 

```{r}
# analizamos las distribuciones de los pesos
cabin_specified_set <- subset(datos[datos$Cabin!="", ], select = c(Cabin, Fare))
cabin_not_specified_set <- subset(datos[datos$Cabin=="", ], select = c(Cabin, Fare))

# Histogram with density plot
g1 <- ggplot(datos[datos$Cabin!="", ], aes(x=Fare)) + 
 geom_histogram(aes(y=..density..), colour="black", fill="white")+
 geom_density(alpha=.2, fill="#FF6666")+
 ggtitle('Cabin specified - Fare')

g2 <- ggplot(datos[datos$Cabin=="", ], aes(x=Fare)) + 
 geom_histogram(aes(y=..density..), colour="black", fill="white")+
 geom_density(alpha=.2, fill="#FF6666")+
 ggtitle('Not cabin specified - Fare')

grid.arrange(g1, g2, ncol=1, nrow=2)

g3 <- ggplot(datos[datos$Cabin!="" & datos$Embarked=='C', ], aes(x=Fare)) + 
 geom_histogram(aes(y=..density..), colour="black", fill="white")+
 geom_density(alpha=.2, fill="#FF6666")+
 ggtitle('Cabin specified - Fare Embarked: C')
 
g4 <- ggplot(datos[datos$Cabin=="" & datos$Embarked=='C', ], aes(x=Fare)) + 
 geom_histogram(aes(y=..density..), colour="black", fill="white")+
 geom_density(alpha=.2, fill="#FF6666")+
 ggtitle('Not cabin specified - Fare Embarked: C')

grid.arrange(g3, g4, ncol=1, nrow=2)
```

Para categorizar la variable **Cabin** separaremos entre los que poseen cabina y los que no. Como es posible observar en la gráfica anterior, la gran cantidad de población se encuentra más cercana al 0 para los que no tienen cabina asignada que para los que sí. Debido a qué se quiere categorizar la variable que cabin manteniendo la máxima coherencia en los datos se usará un umbral de Fare para decidir si es sin cabina o con cabina para aquellos datos que no tengan cabina especificados. Este umbral será a partir de lo que consdieramos un valor atípico leve definido por $Q_3 + 1.5 \cdot IQR$ donde $IQR=Q_3-Q_1$.

```{r}
g1 <- ggplot(datos[datos$Cabin=="" & datos$Embarked!='C', ], aes(y = Fare)
             ) + geom_boxplot()
g2 <- ggplot(datos[datos$Cabin=="" & datos$Embarked!='C', ], aes(y = Fare)
             ) + geom_boxplot() + ylim(c(0,100))

grid.arrange(g1, g2, ncol=2, nrow=1, top = 'BoxPlot Fare, empty Cabin Embarked S and Q')


g3 <- ggplot(datos[datos$Cabin=="" & datos$Embarked=='C', ], aes(y = Fare)
             ) + geom_boxplot() 
g4 <- ggplot(datos[datos$Cabin=="" & datos$Embarked=='C', ], aes(y = Fare)
             ) + geom_boxplot() + ylim(c(0,100))

grid.arrange(g3, g4, ncol=2, nrow=1, top = 'BoxPlot Fare, empty Cabin Embarked C')
```

A continuación, se calculan los umbrales para categorizar las variables nulas.

```{r}
# generamos el threshold de la variable Fare para los Embarked S y Q
cuantiles_S_Q <- quantile(datos[datos$Cabin=="", ]$Fare)
threshold_cabin_S_Q <- cuantiles_S_Q[3] + (1.5 * (cuantiles_S_Q[3]-cuantiles_S_Q[1]))

# generamos el threshold de la variable Fare para los Embarked C
cuantiles_C <- quantile(datos[datos$Cabin=="" & datos$Embarked=='C', ]$Fare)
threshold_cabin_C <- cuantiles_C[3] + (1.5 * (cuantiles_C[3]-cuantiles_C[1]))
```

Categorizamos la variable.

```{r}
# categorize the variables for the Embarked values different to C
categorize_cabin <- function(cabin, fare, embarked) {
  if (embarked == 'C') {
    if (cabin!="" && fare > threshold_cabin_C) "with_cabin" else "without_cabin"
  }
  else {
    if (cabin!="" && fare > threshold_cabin_S_Q) "with_cabin" else "without_cabin"
  }
}

datos$Cabin_cat <- as.factor(mapply(
  categorize_cabin,
  cabin=datos$Cabin,
  fare=datos$Fare,
  embarked=datos$Embarked
))


detach(datos)
attach(datos)

ggplot(data = datos,aes(x=Cabin_cat,fill=Survived))+geom_bar(position="fill")+ylab("Frecuency")
```

 Se puede observar como el hecho de tener cabina aumenta la probabilidad de de supervivencia. Por lo tanto, será una buena variable predictora.

Se realiza un test de chi-cuadrado para comprobar si las variables son dependientes con almenos un nivel de significación del $\alpha = 0.05$.

```{r}
chisq.test(Survived, Cabin_cat)
```

Como se puede observar en el resultado previo, la vriable **Cabin_cat** y la variable **Survived** son dependientes.


### 4.10. Resumen de los datos 
Se adjunta un resumen de los datos. 
```{r resumen fichero}
summary(datos)
```

### 4.11. Guardado de datos
una vez procesados los datos se guardan en formato csv. Se guardaran tambien las variables que no se vayan a usar en la predicción como son **Name**, **Ticket**

```{r guardado}
write.csv(datos, file = "titanic_clean.csv ", row.names = FALSE)
```

## 5. Modelo de clasificación

Usando el algoritmo de RandomForest se va intentar predecir la probabilidad de supervivencia. Para ello primero se entrenará el modelo con 2/3 de los datos y se hará el test con el 1/3 restante

### 5.1. Entrenamiento 

```{r, results='hide'}
library(randomForest)
require(caTools)
library(gmodels)
```


```{r}
# Selección variable clase y variables predictoras
y_variable<-select(datos, Survived)
#x_variables <-select(datos,Pclass,Sex,Age, SibSp, Parch, Fare,Cabin, Embarked)
x_variables <-select(datos,
                     Pclass,
                     Sex,
                     # Age_categoric, predice mejor la otra Age
                     Age_cat,
                     # SibSp,
                     # Parch,
                     # Ticket, # test no la coge el algoritmo por tiene muchos factores
                     Parents,
                     # Fare,
                     Fare, 
                     Cabin_cat,
                     Embarked
                     )

# Seleccion de los indices para los datos de entrenamiento y test
# set.seed(666)
set.seed(333)
train_index <- sample(1:nrow(x_variables), 0.67 * nrow(x_variables))
test_index <- setdiff(1:nrow(x_variables), train_index)

# Construyendo conjunto de entrenamiento y test 
X_train <- x_variables[train_index,]
y_train <- y_variable[train_index,]

X_test <- x_variables[test_index, ]
y_test <- y_variable[test_index, ]

rf <- randomForest(
  y_train ~ .,
  data=X_train
)
summary(rf)
```

### 5.2. Test del modelo 
A continuación se procede a hacer el test del modelo. 

```{r}
pred = predict(rf, newdata=X_test)
cm = table(y_test, pred)
cm
```

```{r}
# Cálculo de la precisión del modelo
predicted_model <- predict( rf, X_test, type="class" )
mat_conf<-table(y_test,Predicted=predicted_model)
porcentaje_correct<-100 * sum(diag(mat_conf)) / sum(mat_conf)
print(sprintf("El %% de registros correctamente clasificados es: %.4f %%",porcentaje_correct))

# Matriz de confusión
CrossTable(y_test, predicted_model,prop.chisq  = FALSE, prop.c = FALSE, prop.r =FALSE,dnn = c('Reality', 'Prediction'))
```

